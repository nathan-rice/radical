<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Radical</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
	<script src="assets/js/modernizr.js"></script>
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">Radical</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> Radical</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="what-is-radical-">What is Radical?</h1>
				<p>Radical is a client API framework, designed to simplify the creation and maintenance of React/Redux applications.
				Radical allows you to model your client API and state via the composition of Actions and Namespaces.</p>
				<ul>
					<li>Actions are the basic unit of functionality; anything that influences state is an Action.</li>
					<li>Namespaces provide a mechanism for organizing and grouping actions.  Namespaces also define the state hierarchy, and
					provide state locality for actions.</li>
				</ul>
				<h1 id="why-radical-">Why Radical?</h1>
				<p>Writing web applications with React and Redux offers a lot of advantages in terms of conceptual simplicity and
					testability.  Unfortunately, the cost of this simplicity is a layer of indirection between initiation of an action and
					its resolution.  Additionally, because state is non-local, you are forced to consider the entire state structure when
					performing updates; even worse, if you decide to change its structure, you have to update your all the reducers that
				traverse that portion of the state.</p>
				<p>Radical was designed solve these problems.</p>
				<p>Using Actions, you can group initiation and resolution functionality
					together.  Even better, by default Actions only have to deal with localized state, and most of the initiation/reduction
					boilerplate has been handled for you.  That doesn&#39;t mean Actions are limiting - most of the default behavior of Actions
				can be easily overridden in the event you need to do something unanticipated.</p>
				<p>Using Namespaces, you have the ability to compose the structure of your API and state from modules.  Because state is
					modular and composable, you are free to design it from the bottom up, rather than having to plan your entire state
					structure ahead of time.  If you decide to change how your state is organized, all you need to do is change how you
					compose Namespaces; all your reducers will just work.  Of course, if you don&#39;t want your state model to match your
					Namespace structure, you can override the default Namespace sub-state resolution behavior easily, and Actions associated
				with that Namespace will still support state locality.</p>
				<h1 id="quick-start">Quick Start</h1>
				<p>Radical is authored in Typescript, and I&#39;ve made every effort to maintain type safety and editor support for things like
					smart code completion while providing dynamic composability.  There are a few cases where you have to make a choice
					between expressiveness and full type safety, or you have to include type hints, but these are limited (don&#39;t worry, I&#39;ll
				highlight them in the examples).</p>
				<p>The first thing you need to do is define a Namespace; there are several ways to do it, lets start off simply, using
				Javascript semantics:</p>
				<pre><code class="lang-typescript">    <span class="hljs-keyword">var</span> store = Redux.createStore(state =&gt; state);

    <span class="hljs-comment">/* You can just create an instance of the Namespace class.  If you do this, you
     * should provide a value for the name attribute, as this is used when
     * constructing Redux action types.  Note that since this is going to be a "root"
     * Namespace, you must also specify a state retrieval function, and the store to
     * dispatch actions to.  This is not necessary for child Namespaces, by default
     * they recursively search ancestor Namespaces for the appropriate values.  You
     * can also pass a defaultState object, which can house Namespace specific
     * configuration.
     *
     * Note: I'm creating and populating Namespace here in a step by step fashion to
     * ease you into Radical gradually, but you don't get type safety or IDE
     * auto-completion this way; I'll show you a better way in a bit.
     */</span>

    <span class="hljs-keyword">var</span> apiRoot = radical.Namespace.create({
        name: <span class="hljs-string">"My root namespace"</span>,
        getState: store.getState,
        dispatch: store.dispatch,
        <span class="hljs-comment">// Note, if you do not specify defaultState, an empty object is assumed</span>
        defaultState: {greeting: <span class="hljs-string">"hello"</span>, target: <span class="hljs-string">"world"</span>}
    });

    <span class="hljs-comment">/* Namespaces provide a reduce function that automatically dispatches relevant
     * portions of state to child components, so you only need to specify the root
     * reducer here.
     */</span>
    store.replaceReducer(apiRoot.reduce);
</code></pre>
				<p>Now lets provide some actions on our Namespace:</p>
				<pre><code class="lang-typescript">    <span class="hljs-comment">/* If your Action only reads state, the configuration is very simple - just pass
     * it a function.  The function being passed here is called the initiator.  By
     * default, actions have access to their parent Namespace's portion of the state
     * tree.
     *
     * Important note: you cannot use the arrow notation when defining the
     * initiator.  This is because the initiator is bound to the Namespace where it
     * is mounted.  This is also why the function for greetTarget has action as an
     * argument; the first argument of Action initiators is bound to the Action
     * itself.
     */</span>
    <span class="hljs-keyword">var</span> greetTarget = radical.Action.create(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action</span>) </span>{
        <span class="hljs-keyword">let</span> state = <span class="hljs-keyword">this</span>.getState();
        <span class="hljs-keyword">return</span> state.greeting + <span class="hljs-string">" "</span> + state.target + <span class="hljs-string">"!"</span>;
    });

    <span class="hljs-comment">/* If your Action needs to modify state, you usually need to specify a reducer;
     * however, if all you want to do is update a value in state, you the default
     * reducer handles that case for you without any additional code.  I'm using an
     * object argument to create here just to expose you to more of the interface.
     */</span>
    <span class="hljs-keyword">var</span> setGreeting = radical.Action.create({
        initiator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, newGreeting</span>) </span>{
            <span class="hljs-comment">/* Note that I am dispatching without an action type.  The dispatch
             * method automatically adds a type property to the passed object
             * with the Action's name property as a value.  Actions that do not
             * have an explicitly set name property have one automatically
             * generated via a combination of the containing Namespace's name
             * and the mount location for the action.
             *
             * Note: An Action's dispatch returns a reference to its parent
             * Namespace, to enable fluent-style method chaining.
             */</span>
            <span class="hljs-keyword">return</span> action.dispatch({greeting: newGreeting});
        }
    })

    <span class="hljs-comment">// For this action I'll specify the reducer manually.</span>
    <span class="hljs-keyword">var</span> setTarget = radical.Action.create({
        initiator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, newTarget</span>) </span>{
            <span class="hljs-keyword">return</span> action.dispatch({target: newTarget});
        },
        <span class="hljs-comment">/* Note that you can directly mutate the passed state, since radical
         * passes each reducer a shallow copy of the parent Namespace's state. Thus
         * as long as you don't directly alter any mutable children of the passed
         * state, any references to old versions of state remain pristine.
         */</span>
        reducer: (state, action) =&gt; {
            state[target] = newTarget;
            <span class="hljs-keyword">return</span> state;
        }
    }

    <span class="hljs-keyword">var</span> rootConfig = {
        components: {
            greetTarget: greetTarget,
            setGreeting: setGreeting
        }
    };

    <span class="hljs-comment">// You can attach Actions to a Namespace using the configure method</span>
    apiRoot.configure(rootConfig);

    <span class="hljs-comment">// You can also use the mount method</span>
    apiRoot.mount(<span class="hljs-string">"setTarget"</span>, setTarget);

    apiRoot.greetTarget(); <span class="hljs-comment">// -&gt; "hello world!"</span>
    apiRoot.setTarget(<span class="hljs-string">"hacker news"</span>).greetTarget(); <span class="hljs-comment">// -&gt; "hello hacker news!"</span>
</code></pre>
				<p>You might have noticed that I use a create factory function rather than the new keyword.  This is the preferred method
					of creating new Radical components.  The reason for this is that when we get into defining Namespaces and Actions using
					Typescript class semantics with instance properties, components created with the new keyword must have their configure
					method called <em>after</em> all constructor functions have resolved or they are not properly instrumented; the create method
				does this for you automatically.</p>
				<p>In Typescript, it is much better to use class semantics to define Namespaces and Actions.  There are a couple of ways of
				going about this, depending on whether you value brevity and uncluttered code or full type safety.</p>
				<pre><code class="lang-typescript">    <span class="hljs-comment">/* First, with an emphasis on uncluttered brevity.  This method will get you editor
     * autocomplete for names, but you won't have type safety on the arguments and
     * return value of actions.  Since this Namespace is going to be a child of our
     * previously created apiRoot Namespace, we don't have to specify getState or
     * store properties.
     *
     * Note: You don't need to specify a name for Namespaces defined this way unless
     * you plan to have more than one instance of it.  If no name attribute is
     * specified, Namespaces will derive a name from their class name.
     */</span>
    <span class="hljs-keyword">class</span> SpanishGreeter extends radical.Namespace {

        defaultState = {greeting: <span class="hljs-string">"hola"</span>, target: <span class="hljs-string">"mundo"</span>};

        greetTarget = radical.Action.create(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action</span>) </span>{
            <span class="hljs-keyword">let</span> state = <span class="hljs-keyword">this</span>.getState();
            <span class="hljs-keyword">return</span> <span class="hljs-string">"¡"</span> + state.greeting + <span class="hljs-string">" "</span> + state.target + <span class="hljs-string">"!"</span>;
        });

        setTarget = radical.Action.create(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, newTarget</span>) </span>{
            action.dispatch({target: newTarget});
        });

        setGreeting = radical.Action.create(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, newGreeting</span>) </span>{
            action.dispatch({greeting: newGreeting});
        });
    }

    <span class="hljs-comment">/* Now, with editor support for type safe usage and return values.  Note that you
     * still don't get compiler assurances that the initiator function of the Action
     * you supplied to the Namespace matches matches the signature definition on the
     * class.
     */</span>
    <span class="hljs-keyword">class</span> FrenchGreeter extends radical.Namespace {

        defaultState = {greeting: <span class="hljs-string">"bonjour"</span>, target: <span class="hljs-string">"le monde"</span>};

        components = {
            greetTarget: radical.Action.create(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action</span>) </span>{
                <span class="hljs-keyword">let</span> state = <span class="hljs-keyword">this</span>.getState();
                <span class="hljs-keyword">return</span> state.greeting + <span class="hljs-string">" "</span> + state.target + <span class="hljs-string">"!"</span>;
            }),

            setTarget: radical.Action.create(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, newTarget</span>) </span>{
                action.dispatch({target: newTarget});
            }),

            setGreeting: radical.Action.create(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, newGreeting</span>) </span>{
                <span class="hljs-keyword">return</span> action.dispatch({greeting: newGreeting});
            })
        }

        greetTarget: () =&gt; <span class="hljs-built_in">string</span>;
        setTarget: (newTarget: <span class="hljs-built_in">string</span>) =&gt; FrenchGreeter;
        setGreeting: (newGreeting: <span class="hljs-built_in">string</span>) =&gt; FrenchGreeter;
    }

    <span class="hljs-comment">/* You can attach Namespaces to other Namespaces in exactly the same way I attached
     * Actions previously.  Note that if you use the configure method, this updates
     * rather than replaces the components on the Namespace.
     *
     * Note: You still won't get full editor autocomplete and type-safety if you attach
     * new Namespaces to a pre-existing Namespace in this way - you need to use class
     * semantics all the way down.
     */</span>
     apiRoot.configure({components: {spanish: SpanishGreeter.create()});
     apiRoot.mount(<span class="hljs-string">"french"</span>, FrenchGreeter.create());

     <span class="hljs-comment">/* For best results in Typescript, just define a class.  This will provide
      * autocomplete and type safety (if you used signature style definitions).
      *
      * Note: I specify names here for the greeters because otherwise their actions
      * would have the same dispatch type as the previously created instances.
      */</span>
     <span class="hljs-keyword">class</span> GreeterContainer extends radical.Namespace {
        spanish = SpanishGreeter.create({name: <span class="hljs-string">"alt spanish"</span>}) as SpanishGreeter;
        french = FrenchGreeter.create({name: <span class="hljs-string">"alt french"</span>}) as FrenchGreeter;
     }

     <span class="hljs-keyword">var</span> newApiRoot = GreeterContainer.create({
        getState: store.getState,
        dispatch: store.dispatch
     });

     store.replaceReducer(newApiRoot.reduce);

     newApiRoot.getState();
     <span class="hljs-comment">/* -&gt; {
      *        spanish: {greeting: "hola", target: "mundo"},
      *        french: {greeting: "bonjour", target: "le monde"}
      *    }
      */</span>
</code></pre>
				<p><strong>Important</strong>: Note that I type-cast SpanishGreeter and FrenchGreeter in the previous code.  This is unfortunately
					necessary in order for the code to compile.  The reason for this is that Typescript doesn&#39;t currently support
					returning polymorphic <strong>this</strong> from static methods.  If this offends you, I suggest leaving a note on the relevant
					<a href="https://github.com/Microsoft/TypeScript/issues/5863">Typescript Github Issue</a> mentioning how much you would like it if
				they made this feature a slightly higher priority.</p>
				<p>Radical includes a few more features for your development pleasure. For actions that need to make an ajax call to the
					server, I&#39;ve included a declarative endpoint description interface.  Additionally, since Immutable is commonly used
					with React/Redux, there are version of Namespace and Action that work with it (or any library that implements a basic
				collection interface) seamlessly.</p>
				<pre><code class="lang-typescript">
    <span class="hljs-comment">/* CollectionNamespace supports Immutable (or any collection with get, set and
     * merge methods).
     */</span>
    <span class="hljs-keyword">class</span> AnotherDemoNamespace extends radical.CollectionNamespace {
        <span class="hljs-comment">/* Note that you MUST set a defaultState for CollectionNamespaces.  This is
         * because I don't assume anything about the type of collection you are
         * using.
         */</span>
        defaultState = Immutable.fromJS({});

        actionWithGetEndpoint = radical.CollectionAction({
            <span class="hljs-comment">/* If your endpoint is accessed using the GET method, and returns text
             * which doesn't need to be transformed (or you want to handle the
             * transformation yourself) you can specify it using just the URL.
             */</span>
            endpoint: <span class="hljs-string">"/get_endpoint_returning_text"</span>,
            initiator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, arg1</span>) </span>{
                action.endpoint.execute({
                    <span class="hljs-built_in">arguments</span>: {foo: arg1, bar: <span class="hljs-number">2</span>},
                    success: (data) =&gt; {
                        action.dispatch({newData: data});
                    }
                });
            }
        });

        actionWithJsonPostEndpoint = radical.CollectionAction({
            endpoint: radical.JsonEndpoint.create({
                url: <span class="hljs-string">"/post_json_endpoint"</span>,
                method: <span class="hljs-string">"POST"</span>
            }),
            initiator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, arg1</span>) </span>{
                action.endpoint.execute({
                    data: {foo: arg1, bar: <span class="hljs-number">2</span>},
                    <span class="hljs-comment">// The data passed to the success function has already been parsed</span>
                    success: (data) =&gt; {
                        action.dispatch({newData: data});
                    },
                    <span class="hljs-comment">/* Note that JsonEndpoint assumes the server is delivering JSON
                     * error messages.  If this is not the case (it really should be!)
                     * you need to provide a function that returns its input unchanged
                     * (e.g. r =&gt; r) as the errorParser argument to the JsonEndpoint.
                     */</span>
                    error: (data, status) =&gt; {
                        <span class="hljs-comment">// handle your business</span>
                    }
                });
            }
        });
    }
</code></pre>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_radical_.html">"radical"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.io" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>